#include <nds.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "letters.h"
#include "device_compatibility.h"
#include "ECG_Plot.h"


volatile pixel buff[256*5];
int lastValue = -1;
unsigned short *fb;
ECG_PLOT* plot;




void timeout()
{
    static int cont_timer;
    int i;

	shift_canvas(plot);
    
    if(lastValue && cont_timer++ == 0)
    {
      volatile unsigned short color;
      //Random point and rescaling of the point
      int r = (rand() % 170) + 1;
      switch(rand()%10){
	case 0: //QRS
	  color = RGB15(31,0,0);
	  printletter(fb,Q,5,228,color);
	  printletter(fb,R,5,236,color);
	  printletter(fb,S,5,244,color);
	  drawLine(plot,240,15,240,(192-r-4),color);
	break;
	case 1: //P
	  color = RGB15(31,18,0);
	  printletter(fb,BLANK,5,228,color);
	  printletter(fb,R,5,236,color);
	  printletter(fb,BLANK,5,244,color);
	  drawLine(plot,240,15,240,(192-r-4),color);
	break;
	case 2: //T
	  color = RGB15(31,0,31);
	  printletter(fb,BLANK,5,228,color);
	  printletter(fb,T,5,236,color);
	  printletter(fb,BLANK,5,244,color);
	  drawLine(plot,240,15,240,(192-r-4),color);
	break;
	default:
	break;
      }
      drawLine(plot, 216,(192-lastValue-4),240,(192-r-4),RGB15(0,0,31));
      lastValue = r;
    }
    cont_timer %= 6;
    drawLine(plot, 240, 138, 255,138, RGB15(0,0,0));
}

int main() 
{
    int lastx, lasty;

    lastx = lasty = -1;
    consoleDemoInit();


/*************************
  Utilizando Rotoscale
*************************/
//   REG_DISPCNT = MODE_5_2D | DISPLAY_BG2_ACTIVE;
//   VRAM_A_CR = VRAM_ENABLE | VRAM_A_MAIN_BG ;
//   BGCTRL[2] = BG_MAP_BASE(0) | BgSize_B16_256x256;
//   uint16 *fb = BG_GFX;
// 
//   bgTransform[2]-> xdx = 1<<8;
//   bgTransform[2]-> ydx = 0;
//   bgTransform[2]-> xdy = 0;
//   bgTransform[2]-> ydy = 1<<8;
//   bgTransform[2]-> dx  = 0<<8;
//   bgTransform[2]-> dy  = 0<<8;


/*************************
  Utilizando Framebuffer
*************************/
    // Configuracion de pantalla principal
    REG_DISPCNT = MODE_FB0 ;      // Framebuffer
    // Configuracion de bloque A de la VRAM
    VRAM_A_CR = VRAM_ENABLE       // Habilitar
      | VRAM_A_LCD ;              // Asignar a LCD
    fb = VRAM_A;


    printf(" \n \
\n \
- 'B' = Borrar pantalla \n \
\n \
- 'A' = Intercambiar pantallas \n \
\n \
- 'Up' = Aumentar frec.\n \
\n \
- 'Down' = Disminuir frec. \n \
\n \
\n \
\n\
 Pinta con el touch-screen!!");

    plot = init_ECG_Plot(fb, 256,192,0,0);
    clear_canvas(plot);

//    int i;
    int freq = 10;
    srand(time(NULL));
        
    drawLine(plot, 0,138, 244,138, RGB15(0,0,0));


//Timer
    irqSet(IRQ_TIMER0, &timeout);
    irqEnable(IRQ_TIMER0);
    TIMER_DATA(0) = TIMER_FREQ_1024(freq);
    TIMER_CR(0) = TIMER_DIV_1024 | TIMER_ENABLE | TIMER_IRQ_REQ;

    for(;;)
    {
	scanKeys();
	if(keysHeld() & KEY_TOUCH) 
	  {
	    touchPosition touch;
	    touchRead(&touch);
	    if(lastx != -1 && (touch.px != 0 && touch.py != 0)) 
	    {
	    	drawLine(plot,lastx,lasty,touch.px,touch.py, RGB15(0,0,0));
	    }
	    lastx = touch.px;
	    lasty = touch.py;
	  } 
      else
	{
	  unsigned key = keysUp();
	  if(key & KEY_A)
	  {
	    lcdSwap();
	  }
	  else if (key & KEY_DOWN)
	  {
	    if(freq > 1) freq--;
	    TIMER_DATA(0) = TIMER_FREQ_1024(freq);
	    TIMER_CR(0) = TIMER_DIV_1024 | TIMER_ENABLE | TIMER_IRQ_REQ;
// 	    dmaCopy((void *)fb,(void *)buff,256*5*2);
// 	    dmaCopy((void *)&fb[256*5],(void *)fb,256*187*2);
// 	    dmaCopy((void *)buff,(void *)&fb[256*187],256*5*2);
	  }
	  else if (key &	 KEY_UP)
	  {
	    if(freq < 40) freq++;
	    TIMER_DATA(0) = TIMER_FREQ_1024(freq);
	    TIMER_CR(0) = TIMER_DIV_1024 | TIMER_ENABLE | TIMER_IRQ_REQ;
// 	    dmaCopy((void *)&fb[256*188],(void *)buff,256*4*2);
// 	    for(i=188;i>3;i-=4)
// 	    {
// 	      dmaCopy((void *)&fb[256*(i-4)],(void *)&fb[256*i],256*4*2);
// 	    }
// 	    dmaCopy((void *)buff,(void *)fb,256*4*2);
	  }
	  else if (key & KEY_LEFT)
	  {
// 	    for(i = 0;i<192;i++)
// 	    {
// 	      dmaCopy((void*)&fb[256*i],(void*)buff,256*2);
// 	      dmaCopy((void*)buff,(void*)&fb[256*i+5],251*2);
// 	      dmaCopy((void*)&buff[251],(void*)&fb[256*i],10);
// 	    }
	  }
	  else if (key & KEY_RIGHT)
	  {
// 	    for(i = 0;i<192;i++)
// 	    {
// 	      dmaCopy((void*)&fb[256*i],(void*)buff,256*2);
// 	      dmaCopy((void*)&buff[5],(void*)&fb[256*i],251*2);
// 	      dmaCopy((void*)buff,(void*)&fb[256*i+251],10);
// 	    }
	  }
	  else if (key & KEY_B)
	  {
	    clear_canvas(plot);
	    lastx = lasty = -1;
	  }
	  else
	  {
	    lastx = lasty = -1;
	  }
	}
      swiWaitForVBlank();
    }
    return 0;
}
