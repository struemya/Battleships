/*
 * Ship.c
 *
 *  Created on: Jan 5, 2018
 *      Author: nds
 */
#include "Ship.h";

Ship* new_Ship(int length) {
	Ship* ship =(Ship*) malloc(sizeof Ship);
	ship->length =length;
	int i =0;
	for(i=0;i<length;i++) {
		ship->cellsDamaged[i] =0;
	}

	return ship;
}
void flip(Ship* ship) {
	if(ship->horizontal) {
		ship->horizontal=0;
	} else {
		ship->horizontal=1;
	}
}
bool attackShip(Ship* ship, int x, int y) {
	int offset;
	if (minDistance(ship, x, y)==0) {
		if (x=ship->xOrigin) offset =abs(ship->yOrigin-y);
		else offset =abs(ship->xOrigin-x);
		ship->cellsDamaged[offset] =1;
		return true;
	} else {
		return false;
	}
}
bool isOverlapping(Ship* ship1, Ship* ship2) {
		int shipX =ship2->xOrigin;
		int shipY =ship2->yOrigin;


		while(i<ship2->length) {
			distance = minDistance(ship1,shipX,shipY);
			if (distance<=1) { //two ships cannot touch each other, hence they need a distance of at least 2
				return true;
			}
			incrementShipCoordinates(ship2->horizontal, &shipX, &shipY);
			i++;
		}
}

int minDistance(Ship* ship, int x, int y) {
	int i=0;
	int distance=0;
	int shipX =ship->xOrigin;
	int shipY =ship->yOrigin;

	while(i<ship.length) {
		distance = min(shipX-x, shipY-y);
		incrementShipCoordinates(ship.horizontal, &shipX, &shipY);
		i++;
	}
}
void incrementShipCoordinates(bool horizontal, int* shipX,int* shipY) {
	if (horizontal ==1) {
		*shipX =*shipX+ 1;
	} else {
		*shipY =*shipY+ 1;
	}
}
int originDistance(Ship* ship, int x, int y) {
	return abs(ship->xOrigin-x)+abs(ship->yOrigin-y); //sum of distance to origin
}
int absMin(int a, int b) {
	a =abs(a);
	b =abs(b);
	return a<b?a:b;
}
int abs(int a) {
	if (a<0) return -a;
	else return a;
}
